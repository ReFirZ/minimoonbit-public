# 中间代码
## 命令式语言
通常基于语句和控制流构建，变量通常可变。
### 三地址码/四元式
强制要求表达式的每个计算步骤都起一个名字，变量可以被重复赋值
### 静态单赋值
强制要求表达式的每个计算步骤都起一个名字，变量不可以被重复赋值，方便分析。

## 函数式语言
通常基于表达式和函数调用构建，变量通常不可变。
### A-Normal Form/K-Normal Form
强制要求表达式的每个计算步骤都起一个名字，控制流表达式中可以嵌套匿名计算步骤。(knf和anf基本一致，只是规范化程度有所差别。)
#### 简单表达式
简单表达式通常是最基本的表达式，由一个函数调用、变量或字面量（常量）组成。这些表达式在 KNF 中是顶层的，并且不涉及嵌套。

    let x = f(a, b)    // 简单函数调用
    let y = 5          // 字面量
    let z = x + y      // 变量组合

#### 简单表达式组（带in）
在KNF中，let ... in 结构用于定义局部变量，并在 in 后的表达式中使用这些变量。这个结构能够清晰地展示变量的作用域。（但是也可以不使用😀）

    let x = f(a, b) in
    let y = g(x) in
    let result = h(y) in
    result


#### 条件表达式
条件表达式在 KNF 中被处理为一系列的赋值和分支。每个分支的结果都应该是顶层的，并且条件判断也应该以赋值形式表示。

    let t = g(x)            // 计算条件
    let t1 = if t > 0 then f(t) else h(y) // 根据条件判断
    let result = t1        // 最终结果


#### 函数表达式

knf上典型编译优化：常量折叠、函数内联、死代码删除、公共子表达式合并、运算强度削弱、循环（闭包）不变量外提等


### Continuation-passing Style
反转程序控制流

